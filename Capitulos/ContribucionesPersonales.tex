\chapter{Contribuciones Personales}
\label{cap:contribucionesPersonales}

\section*{Miguel Curros García}
Mis tareas en el proyecto se centraron en el diseño y desarrollo del motor genérico de videojuegos así como dentro del apartado de \textit{gameplay} todo lo relacionado con el sistema de eventos, tanto a nivel de motor como de editor. Adicionalmente, también creé la gestión de persistencia con lectura y escritura de los archivos de datos específicos del editor y parte del proceso de \textit{build}.

\medskip

En primer lugar, participé en conjunto con Alejandro González en la fase de diseño del motor donde dejamos bien claras cuáles serían las distintas capas de abstracción de la implementación. Desde el principio teníamos claro que la base del motor iba a estar basada en una arquitectura EC (\textit{Entity-Component}), construyendo el resto de las funcionalidades alrededor. Comenzamos a definir cómo estructuraríamos esa arquitectura a través de un diagrama \textit{UML} donde definimos tanto los distintos módulos que formarían el motor como la forma en la que se conectarían las partes más básicas de este con las funcionalidades específicas de \textit{gameplay}.

\medskip
 
A continuación, comencé con el desarrollo de este centrándome en los apartados de carga y gestión de recursos, audio y colisiones. Comenzando con la gestión de recursos, esta es una parte crucial del motor al estar este dirigido por datos; todo aquello que se quiere que ocurra en un juego estará definido en los datos a interpretar al motor.
Esta parte tiene 3 partes clave: \texttt{Resource}, \texttt{ResourceHandler} y \texttt{ResourceMemoryManager}. Cada una de esas clases se encarga de una parte clave de la carga y descarga de recursos. 
\begin{itemize}
	\item \texttt{Resource} servirá de clase base para todos los tipos de recursos que se quieran cargar, cada uno de ellos implementará cómo se carga y descarga desde los archivos de datos.
	\item \texttt{ResourceHandler} será a quien recurran las distintas partes del motor que necesiten cualquier tipo de recurso. A través de la ruta a un recurso de un tipo especificado dará acceso a una instancia conteniendo ese mismo recurso cargado.
	\item Por último, \texttt{ResourceMemoryManager} se encargará de gestionar cuánta memoria está siendo ocupada en este momento por los recursos. A partir de un límite especificado en un archivo de configuración esta clase se encargará de que no se supere ese umbral de memoria máxima ocupada por los recursos. Si se solicitara un recurso y no hubiera memoria suficiente para cargarlo a través de un algoritmo LRU se irá liberando memoria de otros recursos hasta que haya suficiente para cargar el nuevo. Con esto, conseguí estructurar la carga de recursos bajo demanda que evitaría posibles largos tiempos de espera los juegos.
\end{itemize}

\medskip

Una vez esto estaba listo desarrollé el sistema de sonido que permitiría el control sobre la reproducción de archivos de audio dentro de los juegos. Para esto decidimos usar el nuevo sistema de audio de \textit{SDL3} que cumplía todas nuestras necesidades. Nuestro objetivo con este sistema era la implementación de un componente \texttt{AudioSource} a través del que gestionar la reproducción de un archivo de audio. Además, queríamos que cada uno de estos \texttt{AudioSource} pudieran estar asociados a un conjunto de sonidos, pudiendo tener de esta forma un control más profundo del volumen; pues es típico y útil en los videojuegos permitir al jugador controlar el volumen general, de la música o de los efectos por separado.

\smallskip

Para poder reproducir un sonido creé una clase \texttt{AudioClip} que se encargaría de envolver las funcionalidades de \texttt{SDL\_AudioStream}; la base de la reproducción de sonidos en \textit{SDL3}; y ofrecer una interfaz acorde a nuestras necesidades. Para poder asignar estas pistas a distintos conjuntos de sonidos implementé la clase \texttt{AudioMixer}, que tendría un control de volumen asociado que se aplicaría a cada uno de sus \texttt{AudioClip}. Una vez con estas clases básicas pude implementar \texttt{AudioSource} que las utilizaría para ofrecer su funcionalidad esperada.

\medskip

Por último en la base del motor, para la detección y gestión de colisiones buscábamos algo sencillo. Por el tipo de videojuegos que ofrecemos implementar basta con comprobaciones de colisiones entre formas rectangulares. Son comprobaciones sencillas y \textit{SDL} ya ofrece funciones para comprobar si dos rectángulos tienen intersección. Con esto, la implementación de un componente \texttt{Collider} fue sencilla. A través de una clase \texttt{CollisionManager}, en cada actualización del juego se comprobarían las colisiones entre estos \texttt{Collider}. En estas comprobaciones se guardaría la información de qué \texttt{Collider} está colisionando, acaba de empezar a colisionar o acaba de dejar de colisionar con otro. De esta manera se ofrece un control sencillo para implementar comprobaciones dependientes de colisiones entre elementos de juego.

\medskip

Una vez terminamos el apartado del motor genérico comenzamos con el desarrollo de partes específicas de \textit{GamePlay} donde centré mis aportaciones en el sistema de eventos. De cara a ofrecer una experiencia personalizable de crear un videojuego sin necesidad de programar un punto clave era nuestro sistema de eventos. Este se centra alrededor del componente \texttt{EventHandler} que sirve como conjunto de eventos de una entidad. Cada \texttt{Event} está compuesto por una condición, \texttt{EventCondition}, y comportamientos, \texttt{EventBehaviour}.
\begin{itemize}
	\item Comenzando por las condiciones, estas se encargan de manifestar si el estado del juego es el que esperan. Para ello, cada una de las condiciones debe implementar sus propias comprobaciones, esto lo hice a través de un sistema de herencia. Además, igual que pasa con los componentes, cada una de estas condiciones deben poder crearse a partir de los datos proporcionados por el juego, por esta razón creé una clase \texttt{EventConditionFactory}, que se encargaría de instanciar el tipo correspondiente de \texttt{EventCondition} dado un identificador.
	\item Los comportamientos decidimos que estuvieran implementados en \textit{Lua}. De esta manera se podrían ampliar las funcionalidades de un juego sin necesidad de recompilar el motor, ofreciendo una experiencia más flexible. Para implementarlo de la manera que diseñamos era necesario poder tener algún tipo de POO (Programación orientada a objetos) en \textit{Lua}, pero no es algo que ofrezca el lenguaje por defecto. A través de asignar funciones a tablas y modificando sus \textit{metatablas} pude obtener un comportamiento similar a las clases y la herencia. A partir de esa base implementé la clase \texttt{EventBehaviour} en \textit{C++} envolviendo a cada instancia que hubiera en una escena de los distintos comportamientos implementados en \textit{Lua}. Además de esto, para poder implementar cada uno de los comportamientos fue necesario definir desde \textit{C++} qué clases y cómo se podían modificar dentro de las implementaciones de estos en \textit{Lua}.
\end{itemize}

\medskip

Cuando esto estuvo listo comencé con el desarrollo del editor donde creé la gestión de persistencia con lectura y escritura de los archivos de datos específicos del editor. Estos datos decidimos que íbamos a guardarlos también en \textit{Lua} pues nos sería más sencillo de implementar al tener ya la infraestructura montada para ello. Gracias a la clase del editor \texttt{LuaManager} creada por Alejandro Massó, que permite acceder a tablas de \textit{Lua} de un archivo, crear nuevas y guardar estas en nuevos archivos, la tarea consistió en escribir y leer estas tablas. Cada vez que se quisiera salvar un proyecto cada uno de sus recursos guardarían sus parámetros en nuevas tablas de \textit{Lua} que se escribirían en archivos en subdirectorios específicos dentro de un directorio \comillas{projectfiles} dentro de la ruta del proyecto.

\medskip
 
A continuación desarrollé todo el apartado de Eventos, desde la creación, edición y posterior traducción a archivos preparados para ser leídos por el motor. Para este apartado lo primero que hice fue crear una nueva pestaña en el editor, la pestaña de edición de eventos. En esta se podría ver un desplegable donde escoger un evento, una sección donde se mostraría la condición del evento y otra sección donde se mostrarían los comportamientos. 
La parte de creación y selección de eventos fue sencilla, aprovechando que Alejandro Massó ya había implementado la creación y selección de mapas, reutilicé el código que pude para esta parte. Para hacer los apartados de la condición y los comportamientos, igual que con la condición en el motor, tuve que crear factorías que permitieran crear los distintos tipos de instancias de cada uno de estos a partir de identificadores. Esto es porque cada condición y cada comportamiento debe definir en el editor su propia clase, ya que su persistencia e interfaz gráfica difieren entre sí, de modo que requieren implementaciones distintas; además por esa misma persistencia es por lo que se necesita la factoría, cada evento puede tener cualquier tipo de condición o comportamiento y se debe poder reconstruir al abrir un proyecto guardado.

\medskip

Una vez completé todas las interfaces gráficas y la persistencia de todos los tipos de condiciones y comportamientos comencé con el proceso de \textit{build}; convertir estos datos a la sintaxis que el motor reconoce. En el caso de las condiciones fue sencillo, pues el formato en el que guardan su información en el editor es casi idéntico a lo que necesita el motor. Lo que refiere a los comportamientos no es así, hubo dos puntos clave en este apartado: dependencias de componentes y formato de escritura. Algunos de los comportamientos en el motor funcionan por su cuenta, es decir, con que existan dentro de su \texttt{EventHandler} cumplirán su función sin problema; en cambio hay otros que necesitan otros componentes para funcionar también de modo que, para que su proceso de \textit{build} fuera correcto necesitaban indicarle a su entidad que escribiera los componentes faltantes con los parámetros correctos. Por último, a diferencia del resto de proceso de \textit{build} este apartado no podía hacer uso del mecanismo que usamos para escribir el resto de tablas de \textit{Lua}. Esto ocurre porque no estamos añadiendo otra tabla al uso, se necesita la llamada a la construcción de ese \texttt{EventBehaviour} porque el mecanismo de persistencia que se usa en el resto del editor no graba las \textit{metatablas} asociadas a cada tabla, y esto es crucial de cara al funcionamiento de los comportamientos.

\section*{Alejandro González Sánchez}
Mi contribución al Proyecto se ha centrado en el diseño e implementación del motor y parte del editor. En primer lugar, realicé una investigación sobre las posibles formas de adaptar el motor para que pudiera ser multiplataforma, realizando unas primeras pruebas técnicas y de concepto, y acabé decantándome por utilizar \texttt{SDL} como núcleo central del motor, principalmente alentado por todo el soporte multiplataforma que este aporta.

\medskip

Una vez concluido esto, y con una versión básica de \comillas{juego} funcional tanto en Android como en \textit{desktop}, desarrollamos un pequeño programa que mostraba un rectángulo de colores en pantalla, cuyos atributos (tamaño y color) se leían de un archivo \texttt{.lua}. 

A continuación, empecé junto a Miguel Curros García la fase de diseño del motor. En este paso intentamos dejar bien definidas las diferentes partes que íbamos a necesitar, así como la forma en que se comunicarían entre sí. Para ello, generamos un diagrama UML de los diferentes componentes que íbamos a utilizar y lo separamos en diferentes niveles de abstracción, dejando clara la separación entre los componentes básicos del motor y los componentes de \textit{gameplay} que íbamos a necesitar para poder implementar todas las funcionalidades específicas que queríamos para los juegos que ofrece nuestro editor. 

Una vez cerrado este diseño, comenzamos con la implementación. Yo me centré en toda la parte de \texttt{Render}, \texttt{Core} (sistema de Entidades y Componentes) e \texttt{Input}. En primer lugar, desarrollé el \textit{core} del motor: la estructura de Entidades y Componentes, todas ellas organizadas en escenas y gestionadas por un \texttt{SceneManager}. Creé cada una de las partes del ciclo de vida de estos elementos y monté toda la estructura para que pudieran ser cargados a partir de datos leídos de un archivo \texttt{Lua}. Para esto, nos apoyamos en \texttt{ComponentFactory} y en la clase \texttt{ComponentTemplate}, que, a través de una macro y una estructura de plantilla, aceleraba mucho el proceso de declarar nuevos componentes. A continuación, creé la clase \texttt{ComponentData}, que utilizaríamos para poder parametrizar los componentes que declarásemos en Lua. Finalmente, creé unos métodos en el \texttt{SceneManager} para poder instanciar entidades y escenas a partir de unos \textit{blueprints} creados leyendo los archivos Lua correspondientes. 

Una vez terminado esto, pasamos a la parte del \textit{renderizado}. Aquí, generalicé los métodos de pintado de \texttt{SDL} y creé un bucle de \textit{clear}, \textit{present} y \textit{render}, que se llama desde el bucle principal. Para acceder a las funciones de pintado, creé una clase virtual \texttt{RenderComponent} que implementa el método \texttt{render(RenderManager*)}. A continuación, creé todos los componentes básicos de \textit{renderizado} que íbamos a necesitar (\texttt{Camera}, \texttt{Rectangle}, \texttt{Text}, \texttt{SpriteRenderer}, \texttt{Animator}), así como los recursos que estos iban a utilizar (\texttt{Sprite}, \texttt{Animation}, \texttt{Font}, \texttt{Color}). Todo esto quedó integrado con el ciclo de vida que creé en el apartado de \texttt{Core}, para permitir su inicialización parametrizada desde Lua. 

Finalmente, hice una implementación sencilla de un sistema de \textit{input} al que se pudiera acceder desde los componentes. Dado que, por diseño, solo íbamos a utilizar clics/\textit{touchs} para mantener de una forma más simple el soporte multiplataforma, generalicé estos en un \texttt{struct}. Adicionalmente, creé el componente \texttt{Button}, al que se le podía asignar una función de Lua que se llamaría con unos parámetros preestablecidos al detectar un \textit{input} en su área. 

Con esto y las aportaciones de Miguel, dimos por terminado el motor genérico y pasamos a implementar los elementos específicos de \textit{gameplay}. Aquí desarrollé un sistema de diálogo formado principalmente por dos componentes: un gestor de \textit{textboxes}, que mostraba texto poco a poco y esperaba el \textit{input} del usuario, y unas opciones compuestas por varios botones con posibles respuestas por parte del usuario. Lo siguiente fue crear un sistema de movimiento basado en A*, que utilizarían tanto los NPC como el jugador a partir de un input de tipo \textit{point and click}; también añadí la opción de aplicar animaciones como parámetro a este movimiento. Una vez cerrado esto, creé un gestor de mundo cuya función sería controlar qué mapas están activos en escena en cada momento, instanciando nuevos en caso necesario a partir de los \textit{blueprints}. Todos estos sistemas serían la base del \textit{gameplay} de \textit{overworld} que ofrece nuestro editor, combinado con el sistema de eventos. 

Con esto listo, pasamos al desarrollo del editor, que ya tenía una base implementada por Alejandro Massó. Aquí me centré, en primer lugar, en generar un sistema de traducción que convirtiera los datos generados por el editor en datos que siguieran la estructura del motor (entidades, componentes, escenas, \textit{sprites} y animaciones), así como en la generación de otros archivos de configuración. A partir de esto, concreté un proceso de \textit{build} que se encargaría de obtener los binarios precompilados del motor en formato ejecutable y los combinaría con los \textit{assets} del usuario y los archivos de datos en formato motor, previamente traducidos, para obtener el producto final: el juego, contenido en un único directorio denominado \texttt{Build}.  

Posteriormente, implementé otras funcionalidades del editor, como el inspector de objetos, la pestaña de conexiones entre mapas, la pestaña de configuración del jugador y la de configuración general. Para esta última, quise implementar una previsualización para el texto del jugador, por lo que tuve que gestionar una carga asíncrona de fuentes con \texttt{DearImGui}. Todas estas funcionalidades supusieron también una ampliación del sistema de traducción y \textit{build} previamente comentado.  

Por último, me dediqué a realizar pruebas con usuarios y corregir los problemas que encontrábamos en estas. Finalmente, adapté la funcionalidad de \textit{build} para que también fuese posible generar una APK lista para usar en dispositivos Android.

\section*{Alejandro Massó Martínez}
Mi contribución al Proyecto se ha basado en la investigación, diseño y desarrollo del editor, la creación del \textit{toolchain} de generación de dependencias y compilación de los distintos subproyectos, y la redacción de esta memoria.

\medskip

%En primer lugar, hice una exhaustiva investigación acerca de 
