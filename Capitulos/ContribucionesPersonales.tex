\chapter{Contribuciones Personales}
\label{cap:contribucionesPersonales}

\chapterquote{Lo que quiero decir hoy es que, si vamos a contar líneas de código, deberíamos verlas no como líneas generadas, sino como líneas consumidas.}{Edsger W. Dijkstra}


\begin{resumen}
En este capítulo se detalla la contribución de cada uno de los miembros de este trabajo de fin de grado.
\end{resumen}

\section*{Miguel Curros García}
Mis tareas en el proyecto se centraron en el diseño y desarrollo del motor genérico de videojuegos así como dentro del apartado de \textit{gameplay} todo lo relacionado con el sistema de eventos, tanto a nivel de motor como de editor. Adicionalmente, también creé la gestión de persistencia con lectura y escritura de los archivos de datos específicos del editor y parte del proceso de \textit{build}.

\medskip

En primer lugar, participé en conjunto con Alejandro González en la fase de diseño del motor donde dejamos bien claras cuáles serían las distintas capas de abstracción de la implementación. Desde el principio teníamos claro que la base del motor iba a estar basada en una arquitectura EC (\textit{Entity-Component}), construyendo el resto de las funcionalidades alrededor. Comenzamos a definir cómo estructuraríamos esa arquitectura a través de un diagrama \textit{UML} donde definimos tanto los distintos módulos que formarían el motor como la forma en la que se conectarían las partes más básicas de este con las funcionalidades específicas de \textit{gameplay}.

\medskip
 
A continuación, comencé con el desarrollo de este centrándome en los apartados de carga y gestión de recursos, audio y colisiones. Comenzando con la gestión de recursos, esta es una parte crucial del motor al estar este dirigido por datos; todo aquello que se quiere que ocurra en un juego estará definido en los datos a interpretar al motor.
Esta parte tiene 3 partes clave: \texttt{Resource}, \texttt{ResourceHandler} y \texttt{ResourceMemoryManager}. Cada una de esas clases se encarga de una parte clave de la carga y descarga de recursos. 
\begin{itemize}
	\item \texttt{Resource} servirá de clase base para todos los tipos de recursos que se quieran cargar, cada uno de ellos implementará cómo se carga y descarga desde los archivos de datos.
	\item \texttt{ResourceHandler} será a quien recurran las distintas partes del motor que necesiten cualquier tipo de recurso. A través de la ruta a un recurso de un tipo especificado dará acceso a una instancia conteniendo ese mismo recurso cargado.
	\item Por último, \texttt{ResourceMemoryManager} se encargará de gestionar cuánta memoria está siendo ocupada en este momento por los recursos. A partir de un límite especificado en un archivo de configuración esta clase se encargará de que no se supere ese umbral de memoria máxima ocupada por los recursos. Si se solicitara un recurso y no hubiera memoria suficiente para cargarlo a través de un algoritmo LRU se irá liberando memoria de otros recursos hasta que haya suficiente para cargar el nuevo. Con esto, conseguí estructurar la carga de recursos bajo demanda que evitaría posibles largos tiempos de espera los juegos.
\end{itemize}

\medskip

Una vez esto estaba listo desarrollé el sistema de sonido que permitiría el control sobre la reproducción de archivos de audio dentro de los juegos. Para esto decidimos usar el nuevo sistema de audio de \textit{SDL3} que cumplía todas nuestras necesidades. Nuestro objetivo con este sistema era la implementación de un componente \texttt{AudioSource} a través del que gestionar la reproducción de un archivo de audio. Además, queríamos que cada uno de estos \texttt{AudioSource} pudieran estar asociados a un conjunto de sonidos, pudiendo tener de esta forma un control más profundo del volumen; pues es típico y útil en los videojuegos permitir al jugador controlar el volumen general, de la música o de los efectos por separado.

\smallskip

Para poder reproducir un sonido creé una clase \texttt{AudioClip} que se encargaría de envolver las funcionalidades de \texttt{SDL\_AudioStream}; la base de la reproducción de sonidos en \textit{SDL3}; y ofrecer una interfaz acorde a nuestras necesidades. Para poder asignar estas pistas a distintos conjuntos de sonidos implementé la clase \texttt{AudioMixer}, que tendría un control de volumen asociado que se aplicaría a cada uno de sus \texttt{AudioClip}. Una vez con estas clases básicas pude implementar \texttt{AudioSource} que las utilizaría para ofrecer su funcionalidad esperada.

\medskip

Por último en la base del motor, para la detección y gestión de colisiones buscábamos algo sencillo. Por el tipo de videojuegos que ofrecemos implementar basta con comprobaciones de colisiones entre formas rectangulares. Son comprobaciones sencillas y \textit{SDL} ya ofrece funciones para comprobar si dos rectángulos tienen intersección. Con esto, la implementación de un componente \texttt{Collider} fue sencilla. A través de una clase \texttt{CollisionManager}, en cada actualización del juego se comprobarían las colisiones entre estos \texttt{Collider}. En estas comprobaciones se guardaría la información de qué \texttt{Collider} está colisionando, acaba de empezar a colisionar o acaba de dejar de colisionar con otro. De esta manera se ofrece un control sencillo para implementar comprobaciones dependientes de colisiones entre elementos de juego.

\medskip

Una vez terminamos el apartado del motor genérico comenzamos con el desarrollo de partes específicas de \textit{GamePlay} donde centré mis aportaciones en el sistema de eventos. De cara a ofrecer una experiencia personalizable de crear un videojuego sin necesidad de programar un punto clave era nuestro sistema de eventos. Este se centra alrededor del componente \texttt{EventHandler} que sirve como conjunto de eventos de una entidad. Cada \texttt{Event} está compuesto por una condición, \texttt{EventCondition}, y comportamientos, \texttt{EventBehaviour}.
\begin{itemize}
	\item Comenzando por las condiciones, estas se encargan de manifestar si el estado del juego es el que esperan. Para ello, cada una de las condiciones debe implementar sus propias comprobaciones, esto lo hice a través de un sistema de herencia. Además, igual que pasa con los componentes, cada una de estas condiciones deben poder crearse a partir de los datos proporcionados por el juego, por esta razón creé una clase \texttt{EventConditionFactory}, que se encargaría de instanciar el tipo correspondiente de \texttt{EventCondition} dado un identificador.
	\item Los comportamientos decidimos que estuvieran implementados en \textit{Lua}. De esta manera se podrían ampliar las funcionalidades de un juego sin necesidad de recompilar el motor, ofreciendo una experiencia más flexible. Para implementarlo de la manera que diseñamos era necesario poder tener algún tipo de POO (Programación orientada a objetos) en \textit{Lua}, pero no es algo que ofrezca el lenguaje por defecto. A través de asignar funciones a tablas y modificando sus \textit{metatablas} pude obtener un comportamiento similar a las clases y la herencia. A partir de esa base implementé la clase \texttt{EventBehaviour} en \textit{C++} envolviendo a cada instancia que hubiera en una escena de los distintos comportamientos implementados en \textit{Lua}. Además de esto, para poder implementar cada uno de los comportamientos fue necesario definir desde \textit{C++} qué clases y cómo se podían modificar dentro de las implementaciones de estos en \textit{Lua}.
\end{itemize}

\medskip

Cuando esto estuvo listo comencé con el desarrollo del editor donde creé la gestión de persistencia con lectura y escritura de los archivos de datos específicos del editor. Estos datos decidimos que íbamos a guardarlos también en \textit{Lua} pues nos sería más sencillo de implementar al tener ya la infraestructura montada para ello. Gracias a la clase del editor \texttt{LuaManager} creada por Alejandro Massó, que permite acceder a tablas de \textit{Lua} de un archivo, crear nuevas y guardar estas en nuevos archivos, la tarea consistió en escribir y leer estas tablas. Cada vez que se quisiera salvar un proyecto cada uno de sus recursos guardarían sus parámetros en nuevas tablas de \textit{Lua} que se escribirían en archivos en subdirectorios específicos dentro de un directorio \comillas{projectfiles} dentro de la ruta del proyecto.

\medskip
 
A continuación desarrollé todo el apartado de Eventos, desde la creación, edición y posterior traducción a archivos preparados para ser leídos por el motor. Para este apartado lo primero que hice fue crear una nueva pestaña en el editor, la pestaña de edición de eventos. En esta se podría ver un desplegable donde escoger un evento, una sección donde se mostraría la condición del evento y otra sección donde se mostrarían los comportamientos. 
La parte de creación y selección de eventos fue sencilla, aprovechando que Alejandro Massó ya había implementado la creación y selección de mapas, reutilicé el código que pude para esta parte. Para hacer los apartados de la condición y los comportamientos, igual que con la condición en el motor, tuve que crear factorías que permitieran crear los distintos tipos de instancias de cada uno de estos a partir de identificadores. Esto es porque cada condición y cada comportamiento debe definir en el editor su propia clase, ya que su persistencia e interfaz gráfica difieren entre sí, de modo que requieren implementaciones distintas; además por esa misma persistencia es por lo que se necesita la factoría, cada evento puede tener cualquier tipo de condición o comportamiento y se debe poder reconstruir al abrir un proyecto guardado.

\medskip

Una vez completé todas las interfaces gráficas y la persistencia de todos los tipos de condiciones y comportamientos comencé con el proceso de \textit{build}; convertir estos datos a la sintaxis que el motor reconoce. En el caso de las condiciones fue sencillo, pues el formato en el que guardan su información en el editor es casi idéntico a lo que necesita el motor. Lo que refiere a los comportamientos no es así, hubo dos puntos clave en este apartado: dependencias de componentes y formato de escritura. Algunos de los comportamientos en el motor funcionan por su cuenta, es decir, con que existan dentro de su \texttt{EventHandler} cumplirán su función sin problema; en cambio hay otros que necesitan otros componentes para funcionar también de modo que, para que su proceso de \textit{build} fuera correcto necesitaban indicarle a su entidad que escribiera los componentes faltantes con los parámetros correctos. Por último, a diferencia del resto de proceso de \textit{build} este apartado no podía hacer uso del mecanismo que usamos para escribir el resto de tablas de \textit{Lua}. Esto ocurre porque no estamos añadiendo otra tabla al uso, se necesita la llamada a la construcción de ese \texttt{EventBehaviour} porque el mecanismo de persistencia que se usa en el resto del editor no graba las \textit{metatablas} asociadas a cada tabla, y esto es crucial de cara al funcionamiento de los comportamientos.

\section*{Alejandro González Sánchez}
Mi contribución al Proyecto se ha centrado en el diseño e implementación del motor y parte del editor. En primer lugar, realicé una investigación sobre las posibles formas de adaptar el motor para que pudiera ser multiplataforma, realizando unas primeras pruebas técnicas y de concepto, y acabé decantándome por utilizar \texttt{SDL} como núcleo central del motor, principalmente alentado por todo el soporte multiplataforma que este aporta.

\medskip

Una vez concluido esto, y con una versión básica de \comillas{juego} funcional tanto en Android como en \textit{desktop}, desarrollamos un pequeño programa que mostraba un rectángulo de colores en pantalla, cuyos atributos (tamaño y color) se leían de un archivo \texttt{.lua}. 

A continuación, empecé junto a Miguel Curros García la fase de diseño del motor. En este paso intentamos dejar bien definidas las diferentes partes que íbamos a necesitar, así como la forma en que se comunicarían entre sí. Para ello, generamos un diagrama UML de los diferentes componentes que íbamos a utilizar y lo separamos en diferentes niveles de abstracción, dejando clara la separación entre los componentes básicos del motor y los componentes de \textit{gameplay} que íbamos a necesitar para poder implementar todas las funcionalidades específicas que queríamos para los juegos que ofrece nuestro editor. 

Una vez cerrado este diseño, comenzamos con la implementación. Yo me centré en toda la parte de \texttt{Render}, \texttt{Core} (sistema de Entidades y Componentes) e \texttt{Input}. En primer lugar, desarrollé el \textit{core} del motor: la estructura de Entidades y Componentes, todas ellas organizadas en escenas y gestionadas por un \texttt{SceneManager}. Creé cada una de las partes del ciclo de vida de estos elementos y monté toda la estructura para que pudieran ser cargados a partir de datos leídos de un archivo \texttt{Lua}. Para esto, nos apoyamos en \texttt{ComponentFactory} y en la clase \texttt{ComponentTemplate}, que, a través de una macro y una estructura de plantilla, aceleraba mucho el proceso de declarar nuevos componentes. A continuación, creé la clase \texttt{ComponentData}, que utilizaríamos para poder parametrizar los componentes que declarásemos en Lua. Finalmente, creé unos métodos en el \texttt{SceneManager} para poder instanciar entidades y escenas a partir de unos \textit{blueprints} creados leyendo los archivos Lua correspondientes. 

Una vez terminado esto, pasamos a la parte del \textit{renderizado}. Aquí, generalicé los métodos de pintado de \texttt{SDL} y creé un bucle de \textit{clear}, \textit{present} y \textit{render}, que se llama desde el bucle principal. Para acceder a las funciones de pintado, creé una clase virtual \texttt{RenderComponent} que implementa el método \texttt{render(RenderManager*)}. A continuación, creé todos los componentes básicos de \textit{renderizado} que íbamos a necesitar (\texttt{Camera}, \texttt{Rectangle}, \texttt{Text}, \texttt{SpriteRenderer}, \texttt{Animator}), así como los recursos que estos iban a utilizar (\texttt{Sprite}, \texttt{Animation}, \texttt{Font}, \texttt{Color}). Todo esto quedó integrado con el ciclo de vida que creé en el apartado de \texttt{Core}, para permitir su inicialización parametrizada desde Lua. 

Finalmente, hice una implementación sencilla de un sistema de \textit{input} al que se pudiera acceder desde los componentes. Dado que, por diseño, solo íbamos a utilizar clics/\textit{touchs} para mantener de una forma más simple el soporte multiplataforma, generalicé estos en un \texttt{struct}. Adicionalmente, creé el componente \texttt{Button}, al que se le podía asignar una función de Lua que se llamaría con unos parámetros preestablecidos al detectar un \textit{input} en su área. 

Con esto y las aportaciones de Miguel, dimos por terminado el motor genérico y pasamos a implementar los elementos específicos de \textit{gameplay}. Aquí desarrollé un sistema de diálogo formado principalmente por dos componentes: un gestor de \textit{textboxes}, que mostraba texto poco a poco y esperaba el \textit{input} del usuario, y unas opciones compuestas por varios botones con posibles respuestas por parte del usuario. Lo siguiente fue crear un sistema de movimiento basado en A*, que utilizarían tanto los NPC como el jugador a partir de un input de tipo \textit{point and click}; también añadí la opción de aplicar animaciones como parámetro a este movimiento. Una vez cerrado esto, creé un gestor de mundo cuya función sería controlar qué mapas están activos en escena en cada momento, instanciando nuevos en caso necesario a partir de los \textit{blueprints}. Todos estos sistemas serían la base del \textit{gameplay} de \textit{overworld} que ofrece nuestro editor, combinado con el sistema de eventos. 

Con esto listo, pasamos al desarrollo del editor, que ya tenía una base implementada por Alejandro Massó. Aquí me centré, en primer lugar, en generar un sistema de traducción que convirtiera los datos generados por el editor en datos que siguieran la estructura del motor (entidades, componentes, escenas, \textit{sprites} y animaciones), así como en la generación de otros archivos de configuración. A partir de esto, concreté un proceso de \textit{build} que se encargaría de obtener los binarios precompilados del motor en formato ejecutable y los combinaría con los \textit{assets} del usuario y los archivos de datos en formato motor, previamente traducidos, para obtener el producto final: el juego, contenido en un único directorio denominado \texttt{Build}.  

Posteriormente, implementé otras funcionalidades del editor, como el inspector de objetos, la pestaña de conexiones entre mapas, la pestaña de configuración del jugador y la de configuración general. Para esta última, quise implementar una previsualización para el texto del jugador, por lo que tuve que gestionar una carga asíncrona de fuentes con \texttt{DearImGui}. Todas estas funcionalidades supusieron también una ampliación del sistema de traducción y \textit{build} previamente comentado.  

Por último, me dediqué a realizar pruebas con usuarios y corregir los problemas que encontrábamos en estas. Finalmente, adapté la funcionalidad de \textit{build} para que también fuese posible generar una APK lista para usar en dispositivos Android.

\section*{Alejandro Massó Martínez}
Mi contribución al proyecto se ha basado en la investigación, diseño y desarrollo del editor, la creación de la \textit{toolchain} de generación de dependencias y compilación de los distintos subproyectos, y la redacción de este documento.

\medskip

En primer lugar, hice una exhaustiva investigación acerca de distintos editores de videojuegos, tanto específicos de RPG como generalistas, y, con la información obtenida, comencé a dibujar algunos pequeños bocetos de la interfaz de la aplicación, así como recopilar las características más comunes de ambos, para poder implementarlas finalmente en nuestro editor.

\medskip

Posteriormente, implementé, en un repositorio aparte del del desarrollo del proyecto, una primera versión de la estructura del proyecto y de la \textit{toolchain}, utilizando CMake. Pese a que conseguí que se abriese una ventana tanto para el editor como para el ejecutable del juego final, no fui capaz de conseguir la vinculación del proyecto de CMake con \textit{Android Studio} para la generación del APK.

\medskip

Cuando mi compañero Alejandro consiguió la vinculación de \textit{Android Studio} con el CMake principal del proyecto, creé el repositorio final y modifiqué un poco su estructura, dividiéndola en los actuales módulos \comillas{proyectos} y \comillas{código fuente}, lo cual separaba la implementación del código de la declaración de los subdirectorios de CMake, algo que habíamos visto en la asignatura de \comillas{Proyectos 3} durante el transcurso del grado.

\smallskip

Sin embargo, estas modificaciones volvieron a complicar el enlazado de \textit{Android Studio}, pero tras unos arreglos y ajustes, finalmente la estructura final del repositorio estaba lista, y mis compañeros, que ya habían acabado con gran parte del diseño del motor, podían comenzar a programar.

\medskip

Una vez que la estructura del repositorio estaba terminada, y, con la investigación previamente realizada, comencé a diseñar un esquema inicial de clases para el editor utilizando la sintaxis UML. En el esquema, se detallaban las clases \texttt{Project} y \texttt{Window}, así como todos los distintos gestores que se iban a encargar de la inicialización y gestión de distintos módulos del editor. En un principio, el editor iba a utilizar código del motor, por ejemplo, toda la parte de \textit{renderizado}; pero finalmente, y debido a la inclusión de la librería \texttt{DearImGui}, decidí compartimentar e independizar el desarrollo del editor y del motor.

\medskip

Una vez que la estructura de la base estaba diseñada, comencé a implementar las clases en C++. Las clases estaban divididas en tres módulos: \textit{comunes}, \textit{lectura/escritura} y \textit{dibujado}. Comencé por la implementación de las clases comunes, es decir, \texttt{Editor}, que es la clase que se encarga de la inicialización entera del editor y de la inicialización de los gestores; y \texttt{Project}, que contiene la información más relevante de cada uno de los proyectos o juegos que se puedan hacer con el editor.

\smallskip

Después, implementé todos los distintos gestores del editor, como el \texttt{RenderManager}, que se encarga del dibujado de la interfaz en pantalla o el \texttt{InputManager}, que se encarga de la gestión de eventos de entrada del usuario mediante periféricos. Desde un primer momento, quise que el editor pudiese tener la opción de estar en múltiples idiomas, por lo que diseñé e implementé esta opción con el \texttt{LocalizationManager}, que además soporta otros idiomas que todavía no estén incorporados en el editor siempre y cuando se cumpla con la sintaxis esperada.

\smallskip

Implementé también el gestor de las preferencias de usuario, \texttt{PreferencesManager}; el gestor de los proyectos del editor, \texttt{ProjectsManager}, que permite la carga y guardado de los distintos proyectos creados por el usuario; y, el gestor de Lua, \texttt{LuaManager}, no sin antes haber hecho la descarga y compilación de Lua modificando el CMake, que, afortunadamente, debido al trabajo realizado anteriormente, fue una tarea sencilla.

\medskip

Luego de haber implementado todos los gestores que conforman la base del editor, era el turno de la parte de dibujado. La estructura diseñada previamente se conformaba de ventanas y \comillas{subventanas}, por lo que implementé la clase \texttt{Window} y \texttt{Subwindow}, que se aprovechaban de los conceptos de \textit{ventana} y \textit{ventana hija} de \texttt{DearImGui}. Como las ventanas se tienen que mostrar en una determinada jerarquía, implementé también la clase \texttt{WindowStack}. De esta manera, las ventanas que llegan posteriormente y se meten a la pila se renderizan una encima de la otra, como en todos los \textit{softwares} que requieren del uso de múltiples ventanas. Al haber varios tipos de ventana distintos (por ejemplo, las modales o las pestañas) tuve que implementar una interfaz base, \texttt{RenderObject}, que sirviese para todas.

\medskip

Cuando la base de dibujado estaba acabada, mi tarea fue la de implementar otras librerías necesarias para el motor, como \texttt{SDL\_ttf}, \texttt{SDL\_image} o \texttt{sol2}. \texttt{SDL\_ttf} dio algunos problemas con la configuración en CMake, pero al cabo de unos días fue solucionado y pude seguir adelante con el editor.

\smallskip

Primero, modifiqué parte de la implementación que había hecha con Lua para utilizar \texttt{sol2}, que iba a facilitar el desarrollo utilizando esta herramienta. Después, comencé a implementar las primeras ventanas del editor, como \texttt{WelcomeWindow}, que es la ventana de bienvenida que se ve al iniciar el editor. Para ello, tuve que buscar unas fuentes \texttt{.ttf} (decantándome al final por \textit{Raleway}), así como implementar un paquete de iconos para algunos botones. Elegí el paquete de iconos \textit{FontAwesome 6} debido a su fácil inclusión con \texttt{DearImGui}. Una vez terminada la base de la ventana de bienvenida, me dediqué a añadir funcionalidad secundaria a todos los pequeños elementos que se encontraban en esa ventana, como los botones de cada uno de los proyectos o los botones de añadir y eliminar proyecto.

\smallskip

Compaginé el desarrollo de estos elementos con el inicio de la redacción del estado de la cuestión de esta memoria, por lo que, tuve que buscar y leer algunos textos y artículos sobre los juegos de rol y, especialmente, sobre los videojuegos de rol; y pude reutilizar lo que mis compañeros investigaron sobre motores de videojuegos, y lo que investigué sobre editores para la redacción de la parte del desarrollo de videojuegos.

\medskip

Más tarde, tanto Miguel como Alejandro y yo decidimos en una reunión cuáles iban a ser los elementos imprescindibles que el editor tendría que tener en la \textit{build} final, y se decidió por tener un editor de mapas, un editor de objetos, un editor de eventos y un editor de \textit{sprites} y animaciones. Después de esta decisión, \textit{refactoricé} parte del código incorporado para hacerlo más flexible con los nuevos cambios, y comencé con el desarrollo de la ventana principal, \texttt{MainWindow} y del editor de mapas, \texttt{MapEditor}.

\medskip

El grueso del desarrollo del editor se centró en el editor de mapas, añadiendo cada funcionalidad y arreglando cada error que me iba encontrando por el camino. A parte de la estructura principal del editor de mapas, desarrollé los asistentes de creación (o \textit{wizards}) de los mapas y de los \textit{tilesets}. Una vez que la base de los recursos, desarrollada por Miguel, estaba terminada, pude conectarlos con los asistentes ya desarrollados y con el propio editor de mapas, que los necesitaría para poder guardar y modificar.

\medskip

Una vez acabado el editor de mapas, me centré en la redacción de la memoria, comenzando con los capítulos de diseño e implementación, y añadiendo más contenido al estado de la cuestión, que a estas alturas se dividiría en dos capítulos (\textit{Juegos de rol} y \textit{Videojuegos de rol}).

\smallskip

Después, volví a compaginar la redacción de la memoria con el desarrollo de una parte del editor, en este caso, el editor de \textit{sprites} y animaciones, así como los asistentes de creación pertinentes de ambas herramientas. Esta, sin contar el arreglo de algunos errores que me encontré, sería mi última aportación al desarrollo de código en el proyecto. 

Por último, me dediqué a realizar pruebas de usuarios, seguir y acabar con la redacción de la memoria, y arreglar errores que se habían encontrado en el código durante las mencionadas pruebas.